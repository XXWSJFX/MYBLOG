[{"title":"SQL笔试专栏","path":"/2023/11/30/SQL笔试专栏/","content":"SQL笔试专栏1、查询入职员工时间排名倒数第三的员工所有信息描述 有一个员工employees表简况如下: emp_no birth_date first_name last_name gender hire_date 10001 1953-09-02 Georgi Facello M 1986-06-26 10002 1964-06-02 Bezalel Simmel F 1985-11-21 10003 1959-12-03 Parto Bamford M 1986-08-28 10004 1954-05-01 Christian Koblick M 1986-12-01 请你查找employees里入职员工时间排名倒数第三的员工所有信息，以上例子输出如下: emp_no birth_date first_name last_name gender hire_date 10001 1953-09-02 Georgi Facello M 1986-06-26 注意：可能会存在同一个日期入职的员工，所以入职员工时间排名倒数第三的员工可能不止一个。 解题思路 （1）、取出入职日期倒数第三的日期 方案一：利用 limit offset 来实现 找到倒数第三个员工的入职日期。通过在子查询中使用LIMIT和OFFSET来实现。LIMIT 1表示我们只关心一个结果，OFFSET 2表示从第三个结果开始。 在主查询中选择所有入职日期等于上一步得到的日期的员工。 方案二：利用rank() over() 开窗函数 ​ 使用rank()函数为每个员工分配一个排名，排名从1开始，按入职日期降序排列。筛选出排名为3的员工。 ​ rank()对于排序的数据给予相同序号，接下来的数据序号直接跳跃。 （2）注意点：入职员工时间排名倒数第三的员工可能不止一个 测试数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051drop table if exists `employees` ; CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));INSERT INTO employees VALUES(10001,&#x27;1953-09-02&#x27;,&#x27;Georgi&#x27;,&#x27;Facello&#x27;,&#x27;M&#x27;,&#x27;1986-06-26&#x27;);INSERT INTO employees VALUES(10002,&#x27;1964-06-02&#x27;,&#x27;Bezalel&#x27;,&#x27;Simmel&#x27;,&#x27;F&#x27;,&#x27;1985-11-21&#x27;);INSERT INTO employees VALUES(10003,&#x27;1959-12-03&#x27;,&#x27;Parto&#x27;,&#x27;Bamford&#x27;,&#x27;M&#x27;,&#x27;1986-08-28&#x27;);INSERT INTO employees VALUES(10004,&#x27;1954-05-01&#x27;,&#x27;Chirstian&#x27;,&#x27;Koblick&#x27;,&#x27;M&#x27;,&#x27;1986-12-01&#x27;);INSERT INTO employees VALUES(10005,&#x27;1955-01-21&#x27;,&#x27;Kyoichi&#x27;,&#x27;Maliniak&#x27;,&#x27;M&#x27;,&#x27;1989-09-12&#x27;);INSERT INTO employees VALUES(10006,&#x27;1953-04-20&#x27;,&#x27;Anneke&#x27;,&#x27;Preusig&#x27;,&#x27;F&#x27;,&#x27;1989-06-02&#x27;);INSERT INTO employees VALUES(10007,&#x27;1957-05-23&#x27;,&#x27;Tzvetan&#x27;,&#x27;Zielinski&#x27;,&#x27;F&#x27;,&#x27;1989-02-10&#x27;);INSERT INTO employees VALUES(10008,&#x27;1958-02-19&#x27;,&#x27;Saniya&#x27;,&#x27;Kalloufi&#x27;,&#x27;M&#x27;,&#x27;1994-09-15&#x27;);INSERT INTO employees VALUES(10009,&#x27;1952-04-19&#x27;,&#x27;Sumant&#x27;,&#x27;Peac&#x27;,&#x27;F&#x27;,&#x27;1985-02-18&#x27;);INSERT INTO employees VALUES(10010,&#x27;1963-06-01&#x27;,&#x27;Duangkaew&#x27;,&#x27;Piveteau&#x27;,&#x27;F&#x27;,&#x27;1989-08-24&#x27;);INSERT INTO employees VALUES(10011,&#x27;1953-11-07&#x27;,&#x27;Mary&#x27;,&#x27;Sluis&#x27;,&#x27;F&#x27;,&#x27;1990-01-22&#x27;);INSERT INTO employees VALUES(10012,&#x27;1955-01-21&#x27;,&#x27;zhangsan&#x27;,&#x27;Maliniak&#x27;,&#x27;M&#x27;,&#x27;1989-09-12&#x27;);INSERT INTO employees VALUES(10012,&#x27;1955-01-21&#x27;,&#x27;zhangsan&#x27;,&#x27;Maliniak&#x27;,&#x27;M&#x27;,&#x27;1989-09-12&#x27;);SELECT\t* FROM\temployees WHERE\thire_date = ( SELECT hire_date FROM employees ORDER BY hire_date DESC LIMIT 1 OFFSET 2 ) SELECT\temp_no,\tbirth_date,\tfirst_name,\tlast_name,\tgender,\thire_date FROM\t( SELECT *, rank() over ( ORDER BY hire_date DESC ) rt FROM employees ) a WHERE\trt =3 SELECT *, rank() over ( ORDER BY hire_date DESC ) rt FROM employees select *,row_number() over(order by hire_date desc) rt from employees 2、查找各个部门当前领导的薪水详情以及其对应部门名称dept_name描述 请你查找各个部门当前领导的薪水详情以及其对应部门名称dept_name，输出结果以salaries.emp_no升序排序，并且请注意输出结果里面dept_name列是最后一列，输出如下: 有一个全部员工的薪水表salaries简况如下: emp_no salary from_date to_date 10001 88958 2002-06-22 9999-01-01 10002 72527 2001-08-02 9999-01-01 10003 43311 2001-12-01 9999-01-01 有一个各个部门的领导表dept_manager简况如下: dept_no emp_no to_date d001 10001 9999-01-01 d002 10003 9999-01-01 请你查找各个部门当前领导的薪水详情以及其对应部门编号dept_no，输出结果以salaries.emp_no升序排序，并且请注意输出结果里面dept_no列是最后一列，以上例子输出如下: emp_no salary from_date to_date dept_no 10001 88958 2002-06-22 9999-01-01 d001 10003 43311 2001-12-01 9999-01-01 d002 解题思路 员工表dept_no 与部门表dept_no 关联获取dept_name即可 输出结果以salaries.emp_no升序排序： 123456789101112SELECT\te.emp_no,\te.salary,\te.from_date,\te.to_date,\te.dept_no,\td.dept_name FROM\temployees e\tINNER JOIN departments d ON e.dept_no = d.dept_no ORDER BY\te.emp_no ASC; 首先，创建一个示例数据库和表结构。创建表的SQL语句： 123456789101112131415CREATE TABLE departments ( dept_no CHAR(4) PRIMARY KEY, dept_name VARCHAR(20) NOT NULL);CREATE TABLE employees ( emp_no INT PRIMARY KEY, first_name VARCHAR(20) NOT NULL, last_name VARCHAR(20) NOT NULL, salary DECIMAL(10, 2) NOT NULL, from_date DATE NOT NULL, to_date DATE NOT NULL, dept_no CHAR(4), FOREIGN KEY (dept_no) REFERENCES departments(dept_no)); 接下来，我们将插入一些示例数据： 1234567INSERT INTO departments (dept_no, dept_name) VALUES(&#x27;d001&#x27;, &#x27;人事部&#x27;),(&#x27;d002&#x27;, &#x27;财务部&#x27;);INSERT INTO employees (emp_no, first_name, last_name, salary, from_date, to_date, dept_no) VALUES(10001, &#x27;张三&#x27;, &#x27;李四&#x27;, 88958, &#x27;2002-06-22&#x27;, &#x27;9999-01-01&#x27;, &#x27;d001&#x27;),(10003, &#x27;王五&#x27;, &#x27;赵六&#x27;, 43311, &#x27;2001-12-01&#x27;, &#x27;9999-01-01&#x27;, &#x27;d002&#x27;); 3、查找薪水记录超过15条的员工号emp_no描述 有一个薪水表，salaries简况如下: emp_no salary from_date to_date 10001 60117 1986-06-26 1987-06-26 10001 62102 1987-06-26 1988-06-25 10001 66074 1988-06-25 1989-06-25 10001 66596 1989-06-25 1990-06-25 10001 66961 1990-06-25 1991-06-25 10001 71046 1991-06-25 1992-06-24 10001 74333 1992-06-24 1993-06-24 10001 75286 1993-06-24 1994-06-24 10001 75994 1994-06-24 1995-06-24 10001 76884 1995-06-24 1996-06-23 10001 80013 1996-06-23 1997-06-23 10001 81025 1997-06-23 1998-06-23 10001 81097 1998-06-23 1999-06-23 10001 84917 1999-06-23 2000-06-22 10001 85112 2000-06-22 2001-06-22 10001 85097 2001-06-22 2002-06-22 10002 72527 1996-08-03 1997-08-03 请你查找薪水记录超过15条的员工号emp_no以及其对应的记录次数t，以上例子输出如下: emp_no t 10001 16 测试样例 12345678910111213141516171819202122232425262728CREATE TABLE salaries ( emp_no INT, salary INT, from_date DATE, to_date DATE);INSERT INTO salaries (emp_no, salary, from_date, to_date) VALUES (10001, 60117, &#x27;1986-06-26&#x27;, &#x27;1987-06-26&#x27;);INSERT INTO salaries (emp_no, salary, from_date, to_date) VALUES (10001, 62102, &#x27;1987-06-26&#x27;, &#x27;1988-06-25&#x27;);INSERT INTO salaries (emp_no, salary, from_date, to_date) VALUES (10001, 66074, &#x27;1988-06-25&#x27;, &#x27;1989-06-25&#x27;);INSERT INTO salaries (emp_no, salary, from_date, to_date) VALUES (10001, 66596, &#x27;1989-06-25&#x27;, &#x27;1990-06-25&#x27;);INSERT INTO salaries (emp_no, salary, from_date, to_date) VALUES (10001, 66961, &#x27;1990-06-25&#x27;, &#x27;1991-06-25&#x27;);INSERT INTO salaries (emp_no, salary, from_date, to_date) VALUES (10001, 71046, &#x27;1991-06-25&#x27;, &#x27;1992-06-24&#x27;);INSERT INTO salaries (emp_no, salary, from_date, to_date) VALUES (10001, 74333, &#x27;1992-06-24&#x27;, &#x27;1993-06-24&#x27;);INSERT INTO salaries (emp_no, salary, from_date, to_date) VALUES (10001, 75286, &#x27;1993-06-24&#x27;, &#x27;1994-06-24&#x27;);INSERT INTO salaries (emp_no, salary, from_date, to_date) VALUES (10001, 75994, &#x27;1994-06-24&#x27;, &#x27;1995-06-24&#x27;);INSERT INTO salaries (emp_no, salary, from_date, to_date) VALUES (10001, 76884, &#x27;1995-06-24&#x27;, &#x27;1996-06-23&#x27;);INSERT INTO salaries (emp_no, salary, from_date, to_date) VALUES (10001, 80013, &#x27;1996-06-23&#x27;, &#x27;1997-06-23&#x27;);INSERT INTO salaries (emp_no, salary, from_date, to_date) VALUES (10001, 81025, &#x27;1997-06-23&#x27;, &#x27;1998-06-23&#x27;);INSERT INTO salaries (emp_no, salary, from_date, to_date) VALUES (10001, 81097, &#x27;1998-06-23&#x27;, &#x27;1999-06-23&#x27;);INSERT INTO salaries (emp_no, salary, from_date, to_date) VALUES (10001, 84917, &#x27;1999-06-23&#x27;, &#x27;2000-06-22&#x27;);INSERT INTO salaries (emp_no, salary, from_date, to_date) VALUES (10001, 85112, &#x27;2000-06-22&#x27;, &#x27;2001-06-22&#x27;);INSERT INTO salaries (emp_no, salary, from_date, to_date) VALUES (10001, 85097, &#x27;2001-06-22&#x27;, &#x27;2002-06-22&#x27;);INSERT INTO salaries (emp_no, salary, from_date, to_date) VALUES (10002, 72527, &#x27;1996-08-03&#x27;, &#x27;1997-08-03&#x27;);select emp_no,count(1) as t from salaries group by emp_nohaving count(1)&gt;15 GROUP BY和HAVING是一起使用的，用于在查询结果中对分组后的数据进行过滤。 GROUP BY语句用于将结果集按照一个或多个列进行分组，然后对每个分组进行聚合计算。 HAVING语句用于在GROUP BY的结果集中对分组后的数据进行过滤，只返回满足条件的分组。 语法： 1234SELECT 列1, 列2, ... 列nFROM 表名GROUP BY 列1, 列2, ... 列nHAVING 条件; 4、统计每天总刷题数描述 有一个刷题表，exercise_records 简况如下: 1700148734244 统计每天总刷题数，日期降序排列 解题思路： 对日期进行分组，刷题id计数，分组后排序 1234567891011121314151617181920212223242526272829CREATE TABLE exercise_records ( id SERIAL PRIMARY KEY, exercise_id INTEGER,-- 题目id date_of_exercise DATE -- 刷题日期);INSERT INTO exercise_records (exercise_id, date_of_exercise)VALUES (1, &#x27;2022-01-01&#x27;), (2, &#x27;2022-01-01&#x27;), (3, &#x27;2022-01-01&#x27;), (4, &#x27;2022-01-02&#x27;), (1, &#x27;2022-01-02&#x27;), (3, &#x27;2022-01-02&#x27;), (5, &#x27;2022-01-02&#x27;), (6, &#x27;2022-01-03&#x27;); select *from exercise_records SELECT\tdate_of_exercise,\tcount( exercise_id ) AS num FROM\texercise_records GROUP BY\tdate_of_exercise ORDER BY\tdate_of_exercise DESC 5、统计每天刷题数超过5的user_id以及刷题数描述 有一个刷题表，exercise_records 简况如下： id: 自增ID user_id:用户ID exercise_id：刷题id date_of_exercise：刷题日期 1700150685297 统计每天刷题数超过5的user_id以及刷题数 解题思路： 对日期、用户id进行分组，刷题id计数，统计计数大于5的数据 123456789101112131415161718192021222324252627282930313233343536373839404142drop table exercise_records;CREATE TABLE exercise_records ( id SERIAL PRIMARY KEY, user_id INTEGER, exercise_id INTEGER, date_of_exercise DATE);INSERT INTO exercise_records (user_id, exercise_id, date_of_exercise)VALUES (1, 1, &#x27;2022-01-01&#x27;), (1, 2, &#x27;2022-01-01&#x27;), (1, 3, &#x27;2022-01-01&#x27;),\t(1, 4, &#x27;2022-01-01&#x27;),\t(1, 5, &#x27;2022-01-01&#x27;),\t(1, 6, &#x27;2022-01-01&#x27;), (2, 1, &#x27;2022-01-02&#x27;), (2, 2, &#x27;2022-01-02&#x27;), (2, 3, &#x27;2022-01-02&#x27;),\t(3, 1, &#x27;2022-01-03&#x27;), (3, 2, &#x27;2022-01-03&#x27;), (3, 3, &#x27;2022-01-03&#x27;), (3, 4, &#x27;2022-01-03&#x27;), (3, 5, &#x27;2022-01-03&#x27;), (3, 6, &#x27;2022-01-03&#x27;),\t(3, 7, &#x27;2022-01-03&#x27;), (4, 1, &#x27;2022-01-04&#x27;); select *from exercise_records SELECT\tdate_of_exercise,\tuser_id,\tCOUNT(*) AS 刷题数 FROM\texercise_records GROUP BY\tdate_of_exercise,\tuser_id HAVING\tCOUNT(*) &gt; 5; 6、查询所有投递用户user_id并去重描述 简历投递数据表resume_submissions 如下，请你查询所有投递用户user_id并且进行去重展示，查询结果和返回顺序如下 id img 输入： 123456789101112drop table if exists resume_submissions ;CREATE TABLE `resume_submissions ` (`user_id` int NOT NULL,--用户ID`job_id` int NOT NULL,--职位ID`device` varchar(14) NOT NULL,--岗位`job_salary` varchar(32) ,--薪水`deliver_date` date NOT NULL);--投递日期INSERT INTO deliver_record VALUES(101,14550, &#x27;app&#x27;,&#x27;838900&#x27;, &#x27;2020-03-01&#x27;);INSERT INTO deliver_record VALUES(102,14550, &#x27;pc&#x27;,&#x27;67356&#x27;,&#x27;2021-07-07&#x27;);INSERT INTO deliver_record VALUES(103,23654, &#x27;pc&#x27;,null, &#x27;2021-04-09&#x27;);INSERT INTO deliver_record VALUES(102,23152, &#x27;app&#x27;,&#x27;297032&#x27;,&#x27;2022-03-17&#x27;);INSERT INTO deliver_record VALUES(105,75432, &#x27;pc&#x27;,&#x27;156770&#x27;, &#x27;2006-08-15&#x27;); 复制 输出： 12345user_id101102103105 7、获取每个部门中当前员工薪水最高的相关信息描述 有一个员工表dept_emp简况如下: 1700317230498 有一个薪水表salaries简况如下: 1700317201969 获取每个部门中当前员工薪水最高的相关信息，给出dept_no, emp_no以及其对应的salary，按照部门编号dept_no升序排列，以上例子输出如下: 1700318932183 解题思路： 1、获取每个部门最高薪水的员工 2、对部门的薪水进行排序，利用rank() over() ，对薪水降序排列，取第一条 3、部门编号dept_no升序排列 123456789101112131415161718SELECT\tdept_no,\temp_no,\tsalary FROM\t(\tSELECT b.dept_no, b.emp_no, a.salary, rank() over ( PARTITION BY b.dept_no ORDER BY a.salary DESC ) rt FROM salaries a INNER JOIN dept_emp b ON a.emp_no = b.emp_no ) a WHERE\trt = 1order by dept_no – 创建测试数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445drop table if exists `dept_emp` ; drop table if exists `salaries` ; CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));INSERT INTO dept_emp VALUES(10001,&#x27;d001&#x27;,&#x27;1986-06-26&#x27;,&#x27;9999-01-01&#x27;);INSERT INTO dept_emp VALUES(10002,&#x27;d001&#x27;,&#x27;1996-08-03&#x27;,&#x27;9999-01-01&#x27;);INSERT INTO dept_emp VALUES(10003,&#x27;d002&#x27;,&#x27;1996-08-03&#x27;,&#x27;9999-01-01&#x27;);INSERT INTO dept_emp VALUES(10004,&#x27;d002&#x27;,&#x27;1996-08-03&#x27;,&#x27;9999-01-01&#x27;);INSERT INTO dept_emp VALUES(10005,&#x27;d002&#x27;,&#x27;1996-08-03&#x27;,&#x27;9999-01-01&#x27;);INSERT INTO salaries VALUES(10001,88958,&#x27;2002-06-22&#x27;,&#x27;9999-01-01&#x27;);INSERT INTO salaries VALUES(10002,72527,&#x27;2001-08-02&#x27;,&#x27;9999-01-01&#x27;);INSERT INTO salaries VALUES(10003,92527,&#x27;2001-08-02&#x27;,&#x27;9999-01-01&#x27;);INSERT INTO salaries VALUES(10004,92527,&#x27;2001-08-02&#x27;,&#x27;9999-01-01&#x27;);INSERT INTO salaries VALUES(10005,52342,&#x27;2001-08-02&#x27;,&#x27;9999-01-01&#x27;);SELECT\tdept_no,\temp_no,\tsalary FROM\t(\tSELECT b.dept_no, b.emp_no, a.salary, rank() over ( PARTITION BY b.dept_no ORDER BY a.salary DESC ) rt FROM salaries a INNER JOIN dept_emp b ON a.emp_no = b.emp_no ) a WHERE\trt = 1order by dept_no 8、获取所有员工当前的管理者信息题目来自牛客网 描述 有一个员工表dept_emp简况如下: emp_no dept_no from_date to_date 10001 d001 1986-06-26 9999-01-01 10002 d001 1996-08-03 9999-01-01 10003 d002 1995-12-03 9999-01-01 第一行表示为员工编号为10001的部门是d001部门。 有一个部门经理表dept_manager简况如下: dept_no emp_no from_date to_date d001 10002 1996-08-03 9999-01-01 d002 10003 1990-08-05 9999-01-01 第一行表示为d001部门的经理是编号为10002的员工。 获取所有的员工和员工对应的经理，如果员工本身是经理的话则不显示，以上例子如下: emp_no manager 10001 10002 10002和10003本身都是经理 解题思路: 1、员工表与部门经理通过部门ID关联 2、排除员工编号与部门经理表经理编号相同的数据 12345678SELECT\ta.emp_no as emp_no,\t-- a.dept_no,\tb.emp_no as managerFROM\tdept_emp a\tINNER JOIN dept_manager b ON a.dept_no = b.dept_no AND a.emp_no &lt;&gt; b.emp_no 测试数据 123456789101112131415161718192021222324252627282930drop table if exists `dept_emp` ; drop table if exists `dept_manager` ; CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));INSERT INTO dept_emp VALUES(10001,&#x27;d001&#x27;,&#x27;1986-06-26&#x27;,&#x27;9999-01-01&#x27;);INSERT INTO dept_emp VALUES(10002,&#x27;d001&#x27;,&#x27;1996-08-03&#x27;,&#x27;9999-01-01&#x27;);INSERT INTO dept_emp VALUES(10003,&#x27;d002&#x27;,&#x27;1995-12-03&#x27;,&#x27;9999-01-01&#x27;);INSERT INTO dept_manager VALUES(&#x27;d001&#x27;,10002,&#x27;1996-08-03&#x27;,&#x27;9999-01-01&#x27;);INSERT INTO dept_manager VALUES(&#x27;d002&#x27;,10003,&#x27;1990-08-05&#x27;,&#x27;9999-01-01&#x27;);SELECT\ta.emp_no as emp_no,\ta.dept_no,\tb.emp_no as managerFROM\tdept_emp a\tINNER JOIN dept_manager b ON a.dept_no = b.dept_no AND a.emp_no &lt;&gt; b.emp_no 9、获取所有非manager的员工emp_no题目来自牛客网 描述 有一个员工表employees简况如下: emp_no birth_date first_name last_name gender hire_date 10001 1953-09-02 Georgi Facello M 1986-06-26 10002 1964-06-02 Bezalel Simmel F 1985-11-21 10003 1959-12-03 Parto Bamford M 1986-08-28 有一个部门领导表dept_manager简况如下: dept_no emp_no from_date to_date d001 10002 1996-08-03 9999-01-01 d002 10003 1990-08-05 9999-01-01 请你找出所有非部门领导的员工emp_no，以上例子输出: emp_no 10001 解题思路： 方案1： 员工表员工id不在部门表内 方案2： 采用左连接 ，取部门表数据为空的结果 1234567891011-- 方案1 NOT IN+子查询select emp_nofrom employeeswhere emp_no not in (select emp_no from dept_manager);-- 方案2 LEFT JOIN左连接 判断IS NULLSELECT e.emp_no,d.dept_no,d.emp_noFROM employees AS eLEFT JOIN dept_manager AS dON e.emp_no=d.emp_noWHERE dept_no IS NULL; 12345678910111213141516171819202122--测试数据drop table if exists `dept_manager` ; drop table if exists `employees` ; CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));INSERT INTO dept_manager VALUES(&#x27;d001&#x27;,10002,&#x27;1996-08-03&#x27;,&#x27;9999-01-01&#x27;);INSERT INTO dept_manager VALUES(&#x27;d002&#x27;,10003,&#x27;1990-08-05&#x27;,&#x27;9999-01-01&#x27;);INSERT INTO employees VALUES(10001,&#x27;1953-09-02&#x27;,&#x27;Georgi&#x27;,&#x27;Facello&#x27;,&#x27;M&#x27;,&#x27;1986-06-26&#x27;);INSERT INTO employees VALUES(10002,&#x27;1964-06-02&#x27;,&#x27;Bezalel&#x27;,&#x27;Simmel&#x27;,&#x27;F&#x27;,&#x27;1985-11-21&#x27;);INSERT INTO employees VALUES(10003,&#x27;1959-12-03&#x27;,&#x27;Parto&#x27;,&#x27;Bamford&#x27;,&#x27;M&#x27;,&#x27;1986-08-28&#x27;); 10、查找employees表emp_no与last_name的员工信息描述 有一个员工表employees简况如下: emp_no birth_date first_name last_name gender hire_date 10001 1953-09-02 Georgi Facello M 1986-06-26 10002 1964-06-02 Bezalel Simmel F 1985-11-21 10003 1959-12-03 Bezalel Mary M 1986-08-28 10004 1954-05-01 Christian Koblick M 1986-12-01 10005 1953-11-07 Mary Sluis F 1990-01-22 请你查找employees表所有emp_no为奇数，且last_name不为Mary的员工信息，并按照hire_date逆序排列，以上例子查询结果如下: emp_no birth_date first_name last_name gender hire_date 10005 1953-11-07 Mary Sluis F 1990-01-22 10001 1953-09-02 Georgi Facello M 1986-06-26 解题思路 1、求出emp_no为奇数的数据 12--奇数除以2的余数始终为1SELECT emp_no FROM employees WHERE emp_no % 2 = 1; 2、last_name不等于Mary的员工 123SELECT *FROM employeeswhere last_name&lt;&gt;&#x27;Mary&#x27; 3、hire_date降序排列 desc 汇总语句如下 12345SELECT *FROM employeesWHERE emp_no % 2 = 1AND last_name&lt;&gt;&#x27;Mary&#x27;ORDER BY hire_date DESC; 测试用例 123456789101112131415drop table if exists `employees` ; CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));INSERT INTO employees VALUES(10001,&#x27;1953-09-02&#x27;,&#x27;Georgi&#x27;,&#x27;Facello&#x27;,&#x27;M&#x27;,&#x27;1986-06-26&#x27;);INSERT INTO employees VALUES(10002,&#x27;1964-06-02&#x27;,&#x27;Bezalel&#x27;,&#x27;Simmel&#x27;,&#x27;F&#x27;,&#x27;1985-11-21&#x27;);INSERT INTO employees VALUES(10003,&#x27;1959-12-03&#x27;,&#x27;Bezalel&#x27;,&#x27;Mary&#x27;,&#x27;M&#x27;,&#x27;1986-08-28&#x27;);INSERT INTO employees VALUES(10004,&#x27;1954-05-01&#x27;,&#x27;Chirstian&#x27;,&#x27;Koblick&#x27;,&#x27;M&#x27;,&#x27;1986-12-01&#x27;);INSERT INTO employees VALUES(10005,&#x27;1953-11-07&#x27;,&#x27;Mary&#x27;,&#x27;Sluis&#x27;,&#x27;F&#x27;,&#x27;1990-01-22&#x27;); 11、获取当前薪水第二多的员工的emp_no以及其对应的薪水salary描述 有一个薪水表salaries简况如下: emp_no salary from_date to_date 10001 88958 2002-06-22 9999-01-01 10002 72527 2001-08-02 9999-01-01 10003 43311 2001-12-01 9999-01-01 请你获取薪水第二多的员工的emp_no以及其对应的薪水salary， 若有多个员工的薪水为第二多的薪水，则将对应的员工的emp_no和salary全部输出，并按emp_no升序排序。 emp_no salary 10002 72527 解题思路 （1）、取出入职日期倒数第三的日期 方案一：利用 limit offset 来实现 找到薪水排名第二的信息。通过在子查询中使用LIMIT和OFFSET来实现。 “LIMIT 1” 表示只返回一行数据，而 “OFFSET 1” 表示从第二行开始返回 在主查询中选择所有员工编号等于上一步得到的员工编号。 12345678910111213141516171819202122SELECT\temp_no,\tsalary FROM\tsalaries WHEREsalary = ( SELECT salary FROM salaries WHERE to_date = &#x27;9999-01-01&#x27; GROUP BY salary ORDER BY salary DESC LIMIT 1 OFFSET 1 )and to_date = &#x27;9999-01-01&#x27; order by emp_no 方案二：利用rank() over() 开窗函数 ​ 使用rank()函数对薪水降序排列，排名从1开始，按薪水降序降序排列。筛选出排名为2的员工。 ​ rank()对于排序的数据给予相同序号，接下来的数据序号直接跳跃。 123456789101112SELECT\temp_no,\tsalary FROM ( SELECT emp_no, salary, rank() over ( ORDER BY salary DESC ) AS rt FROM salaries WHERE to_date = &#x27;9999-01-01&#x27; ) aWHERE\trt =2order by emp_no 测试用例 1234567891011drop table if exists `salaries` ; CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));INSERT INTO salaries VALUES(10001,88958,&#x27;2002-06-22&#x27;,&#x27;9999-01-01&#x27;);INSERT INTO salaries VALUES(10002,72527,&#x27;2001-08-02&#x27;,&#x27;9999-01-01&#x27;);INSERT INTO salaries VALUES(10003,72527,&#x27;2001-08-02&#x27;,&#x27;9999-01-01&#x27;);INSERT INTO salaries VALUES(10004,43311,&#x27;2001-12-01&#x27;,&#x27;9999-01-01&#x27;); 每日更新：更多资料请关注公众号小肖学数据分析 1700303043874","tags":["笔试"],"categories":["sql笔试，MySQL"]},{"title":"我的第一篇博客","path":"/2023/11/30/我的第一篇博客/","content":"哈啊啊啊啊啊"},{"title":"Hello World","path":"/2023/11/30/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]